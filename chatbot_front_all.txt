


===== frontend/src/components/ui/Card.tsx =====


import React from "react";
import { motion } from "framer-motion";

interface CardProps {
  title: string;
  description?: string;
  image_url?: string;
  tech_stack?: string;
  github_url?: string;
  live_url?: string;
}

const Card: React.FC<CardProps> = ({
  title,
  description,
  image_url,
  tech_stack,
  github_url,
  live_url,
}) => {
  return (
    <motion.div
      className="bg-card border border-[#333] rounded-xl p-fluid-4 flex flex-col shadow-md hover:shadow-xl transition-transform duration-300"
      whileHover={{ scale: 1.03 }}
    >
      {image_url && (
        <img
          src={image_url}
          alt={title}
          className="w-full h-48 object-cover rounded-lg mb-fluid-2"
        />
      )}
      <h3 className="text-fluid-lg font-semibold mb-fluid-1 text-accent">{title}</h3>
      {description && <p className="text-text-muted mb-fluid-1">{description}</p>}
      {tech_stack && <p className="text-sm text-text-muted mb-fluid-1">{tech_stack}</p>}
      <div className="flex gap-fluid-2 mt-auto">
        {github_url && (
          <a href={github_url} target="_blank" rel="noopener noreferrer" className="text-accent hover:underline text-fluid-sm md:text-fluid-base">
            GitHub
          </a>
        )}
        {live_url && (
          <a href={live_url} target="_blank" rel="noopener noreferrer" className="text-accent hover:underline text-fluid-sm md:text-fluid-base">
            Live
          </a>
        )}
      </div>
    </motion.div>
  );
};

export default Card;


===== frontend/src/components/ui/ThreeBackground.tsx =====


import { useEffect, useRef } from "react";
import * as THREE from "three";

const ThreeBackground = () => {
  const mountRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!mountRef.current) return;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 6;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x0a0a0a, 1); // fond noir profond
    renderer.setPixelRatio(window.devicePixelRatio);
    mountRef.current.appendChild(renderer.domElement);

    // ‚ú® Points ‚Äú√©toiles‚Äù ronds
    const particlesCount = 150;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particlesCount * 3);
    for (let i = 0; i < particlesCount * 3; i++) {
      positions[i] = (Math.random() - 0.5) * 12;
    }
    geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    // Cr√©er une texture circulaire pour les particules
    const circle = document.createElement("canvas");
    circle.width = 64;
    circle.height = 64;
    const ctx = circle.getContext("2d");
    if (ctx) {
      ctx.beginPath();
      ctx.arc(32, 32, 32, 0, Math.PI * 2);
      ctx.fillStyle = "#00ff99"; // vert pastel
      ctx.fill();
    }
    const texture = new THREE.CanvasTexture(circle);

    const material = new THREE.PointsMaterial({
      color: 0x00ff99,
      size: 0.08,
      map: texture,
      alphaTest: 0.5,
      transparent: true,
    });

    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // üñ±Ô∏è Interaction souris
    const mouse = new THREE.Vector2(0, 0);
    window.addEventListener("mousemove", (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    });

    // üéûÔ∏è Animation
    const animate = () => {
      requestAnimationFrame(animate);
      points.rotation.y += 0.0015;
      points.rotation.x += 0.001;

      camera.position.x += (mouse.x * 2 - camera.position.x) * 0.05;
      camera.position.y += (mouse.y * 1 - camera.position.y) * 0.05;

      renderer.render(scene, camera);
    };
    animate();

    // üìè Resize
    const handleResize = () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    };
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
      mountRef.current?.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, []);

  return (
    <div
      ref={mountRef}
      className="absolute top-0 left-0 w-screen h-screen z-0"
    />
  );
};

export default ThreeBackground;


===== frontend/src/components/ui/Capsule.tsx =====


import { motion } from "framer-motion";
import { useNavigate } from "react-router-dom";
import { useState } from "react";

interface CapsuleProps {
  label: string;
  to: string;
}

const Capsule: React.FC<CapsuleProps> = ({ label, to }) => {
  const navigate = useNavigate();
  const [isAnimating, setIsAnimating] = useState(false);

  const handleClick = async () => {
    if (isAnimating) return;
    setIsAnimating(true);

    // Pr√©chargement du composant cible
    import(`@pages${to === "/visualization" ? "/Visualization" : "/Home"}`);

    await new Promise((resolve) => setTimeout(resolve, 2000));
    navigate(to);
  };

  return (
    <motion.button
      onClick={handleClick}
      disabled={isAnimating}
      className="px-fluid-6 py-fluid-2 rounded-full border border-[#333] text-text-main 
                 hover:border-accent hover:text-accent transition-all duration-300 
                 bg-card shadow-md text-fluid-base md:text-fluid-lg"
      whileHover={{ scale: 1.08 }}
      whileTap={{ scale: 0.96 }}
    >
      {label}
    </motion.button>
  );
};

export default Capsule;


===== frontend/src/components/ui/SectionTitle.tsx =====


import React from "react";

interface SectionTitleProps {
  title: string;
}

const SectionTitle: React.FC<SectionTitleProps> = ({ title }) => {
  return (
    <h2 className="text-fluid-2xl md:text-fluid-3xl font-bold text-center mb-fluid-2 text-text-main">
      {title}
    </h2>
  );
};

export default SectionTitle;


===== frontend/src/components/ui/Input.tsx =====




===== frontend/src/context/AuthContext.tsx =====


// frontend/src/context/AuthContext.tsx



import { createContext, useContext, useState, useEffect, type ReactNode } from "react";

import apiClient from "@api/apiClient";

export interface UserRead {
  id: string;
  email: string;
  is_active: boolean;
  is_admin: boolean;
  created_at: string;
  updated_at: string;
}

interface AuthContextType {
  user: UserRead | null;
  token: string | null;
  login: (email: string, password: string) => Promise<void>;
  signup: (email: string, password: string) => Promise<void>;
  logout: () => void;
  fetchCurrentUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<UserRead | null>(null);
  const [token, setToken] = useState<string | null>(() => localStorage.getItem("access_token"));

  const login = async (email: string, password: string) => {
    const res = await apiClient.post("/api/v1/auth/login", { username: email, password });
    localStorage.setItem("access_token", res.data.access_token);
    setToken(res.data.access_token);
    await fetchCurrentUser();
  };

  const signup = async (email: string, password: string) => {
    await apiClient.post("/api/v1/auth/signup", { email, password });
  };

  const logout = () => {
    localStorage.removeItem("access_token");
    setToken(null);
    setUser(null);
  };

  const fetchCurrentUser = async () => {
    if (!token) return;
    try {
      const res = await apiClient.get("/api/v1/auth/me");
      setUser(res.data);
    } catch {
      logout();
    }
  };

  useEffect(() => {
    fetchCurrentUser();
  }, [token]);

  return (
    <AuthContext.Provider value={{ user, token, login, signup, logout, fetchCurrentUser }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};


===== frontend/src/hooks/useTypingEffect.ts =====


import { useState, useEffect } from "react";

export function useTypingEffect(text: string, speed = 100) {
  const [displayed, setDisplayed] = useState("");

  useEffect(() => {
    let i = 0;
    const interval = setInterval(() => {
      setDisplayed(text.slice(0, i + 1));
      i++;
      if (i === text.length) clearInterval(interval);
    }, speed);
    return () => clearInterval(interval);
  }, [text, speed]);

  return displayed;
}


===== frontend/src/hooks/useAuth.ts =====




===== frontend/src/hooks/useFetch.ts =====




===== frontend/src/api/project.ts =====


// src/api/projects.ts
import axios from "axios";

export interface ProjectRead {
  id: number;
  title: string;
  description?: string;
  tech_stack?: string;
  github_url?: string;
  live_url?: string;
  image_url?: string;
  is_featured?: boolean;
  created_at: string;
  updated_at: string;
}

export interface ProjectCreate {
  title: string;
  description?: string;
  tech_stack?: string;
  github_url?: string;
  live_url?: string;
  image_url?: string;
  is_featured?: boolean;
}

export interface ProjectUpdate {
  title?: string;
  description?: string;
  tech_stack?: string;
  github_url?: string;
  live_url?: string;
  image_url?: string;
  is_featured?: boolean;
}

const API_URL = import.meta.env.VITE_API_URL || "http://localhost:8000/api/v1/projects";

const getAuthHeader = () => {
  const token = localStorage.getItem("access_token");
  return token ? { Authorization: `Bearer ${token}` } : {};
};

export const fetchProjects = async (skip = 0, limit = 100): Promise<ProjectRead[]> => {
  const response = await axios.get<ProjectRead[]>(`${API_URL}?skip=${skip}&limit=${limit}`);
  return response.data;
};

export const fetchProjectById = async (id: number): Promise<ProjectRead> => {
  const response = await axios.get<ProjectRead>(`${API_URL}/${id}`);
  return response.data;
};

export const createProject = async (project: ProjectCreate): Promise<ProjectRead> => {
  const response = await axios.post<ProjectRead>(API_URL, project, { headers: getAuthHeader() });
  return response.data;
};

export const updateProject = async (id: number, project: ProjectUpdate): Promise<ProjectRead> => {
  const response = await axios.put<ProjectRead>(`${API_URL}/${id}`, project, { headers: getAuthHeader() });
  return response.data;
};

export const deleteProject = async (id: number): Promise<ProjectRead> => {
  const response = await axios.delete<ProjectRead>(`${API_URL}/${id}`, { headers: getAuthHeader() });
  return response.data;
};


===== frontend/src/api/education.ts =====


// src/api/education.ts
import axios from "axios";

export interface EducationRead {
  id: string;
  degree: string;
  school?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface EducationCreate {
  degree: string;
  school?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
  description?: string;
}

export interface EducationUpdate {
  degree?: string;
  school?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
  description?: string;
}

const API_URL = import.meta.env.VITE_API_URL || "http://localhost:8000/api/v1/education";

const getAuthHeader = () => {
  const token = localStorage.getItem("access_token");
  return token ? { Authorization: `Bearer ${token}` } : {};
};

export const fetchEducations = async (skip = 0, limit = 100): Promise<EducationRead[]> => {
  const response = await axios.get<EducationRead[]>(`${API_URL}?skip=${skip}&limit=${limit}`);
  return response.data;
};

export const fetchEducationById = async (id: string): Promise<EducationRead> => {
  const response = await axios.get<EducationRead>(`${API_URL}/${id}`);
  return response.data;
};

export const createEducation = async (edu: EducationCreate): Promise<EducationRead> => {
  const response = await axios.post<EducationRead>(API_URL, edu, { headers: getAuthHeader() });
  return response.data;
};

export const updateEducation = async (id: string, edu: EducationUpdate): Promise<EducationRead> => {
  const response = await axios.put<EducationRead>(`${API_URL}/${id}`, edu, { headers: getAuthHeader() });
  return response.data;
};

export const deleteEducation = async (id: string): Promise<EducationRead> => {
  const response = await axios.delete<EducationRead>(`${API_URL}/${id}`, { headers: getAuthHeader() });
  return response.data;
};


===== frontend/src/api/experience.ts =====


import axios from "axios";

export interface ExperienceRead {
  id: string;
  title: string;
  company?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface ExperienceCreate {
  title: string;
  company?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
  description?: string;
}

export interface ExperienceUpdate {
  title?: string;
  company?: string;
  start_date?: string;
  end_date?: string;
  location?: string;
  description?: string;
}

const API_URL = import.meta.env.VITE_API_URL || "http://localhost:8000/api/v1/experience";

const getAuthHeader = () => {
  const token = localStorage.getItem("access_token");
  return token ? { Authorization: `Bearer ${token}` } : {};
};

export const fetchExperiences = async (skip = 0, limit = 100): Promise<ExperienceRead[]> => {
  const response = await axios.get<ExperienceRead[]>(`${API_URL}?skip=${skip}&limit=${limit}`);
  return response.data;
};


===== frontend/src/api/apiClient.ts =====


// frontend/src/api/apiClient.ts


import axios from "axios";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:8000";

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
});

// Interceptor pour ajouter le token √† chaque requ√™te
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("access_token"); // ou context si on veut memory
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

export default apiClient;


===== frontend/src/api/skill.ts =====


import axios from "axios";

export interface SkillRead {
  id: string;
  name: string;
  level?: number;
  category?: string;
  created_at: string;
  updated_at: string;
}

export interface SkillCreate {
  name: string;
  level?: number;
  category?: string;
}

export interface SkillUpdate {
  name?: string;
  level?: number;
  category?: string;
}

const API_URL = import.meta.env.VITE_API_URL || "http://localhost:8000/api/v1/skill";

const getAuthHeader = () => {
  const token = localStorage.getItem("access_token");
  return token ? { Authorization: `Bearer ${token}` } : {};
};

export const fetchSkills = async (skip = 0, limit = 100): Promise<SkillRead[]> => {
  const response = await axios.get<SkillRead[]>(`${API_URL}?skip=${skip}&limit=${limit}`);
  return response.data;
};


===== frontend/src/pages/Projects.tsx =====


import React, { useEffect, useState } from "react";
import { fetchProjects } from "../api/project";
import type { ProjectRead } from "../api/project";
import Card from "../components/ui/Card";

const Projects: React.FC = () => {
  const [projects, setProjects] = useState<ProjectRead[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadProjects = async () => {
      try {
        const data = await fetchProjects();
        setProjects(data);
      } catch {
        setError("Erreur lors du chargement des projets.");
      } finally {
        setLoading(false);
      }
    };
    loadProjects();
  }, []);

  if (loading) return <p className="text-center mt-fluid-4 text-fluid-base">Chargement...</p>;
  if (error) return <p className="text-center mt-fluid-4 text-red-500 text-fluid-base">{error}</p>;

  return (
    <div className="container mx-auto px-fluid-4 py-fluid-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-fluid-4">
      {projects.map((project) => (
        <Card
          key={project.id}
          title={project.title}
          description={project.description}
          tech_stack={project.tech_stack}
          github_url={project.github_url}
          live_url={project.live_url}
          image_url={project.image_url}
        />
      ))}
    </div>
  );
};

export default Projects;


===== frontend/src/pages/Experience.tsx =====


import React, { useEffect, useState } from "react";
import type { ExperienceRead } from "../api/experience";
import { fetchExperiences } from "../api/experience";
import Card from "../components/ui/Card";

const ExperiencePage: React.FC = () => {
  const [experiences, setExperiences] = useState<ExperienceRead[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadExperiences = async () => {
      try {
        const data = await fetchExperiences();
        setExperiences(data);
      } catch {
        setError("Erreur lors du chargement des exp√©riences.");
      } finally {
        setLoading(false);
      }
    };
    loadExperiences();
  }, []);

  if (loading) return <p className="text-center mt-fluid-4 text-fluid-base">Chargement...</p>;
  if (error) return <p className="text-center mt-fluid-4 text-red-500 text-fluid-base">{error}</p>;

  return (
    <div className="container mx-auto px-fluid-4 py-fluid-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-fluid-4">
      {experiences.map((exp) => (
        <Card
          key={exp.id}
          title={exp.title}
          description={exp.description ?? undefined}
          tech_stack={`${exp.company ?? ""} ‚Ä¢ ${exp.start_date ? new Date(exp.start_date).getFullYear() : ""} - ${exp.end_date ? new Date(exp.end_date).getFullYear() : "Pr√©sent"}`}
          image_url={undefined}
        />
      ))}
    </div>
  );
};

export default ExperiencePage;


===== frontend/src/pages/Home.tsx =====


import Layout from "@components/layout/Layout";
import PageWrapper from "@components/layout/PageWrapper";
import ThreeBackground from "@components/ui/ThreeBackground";
import { motion } from "framer-motion";
import { useTypingEffect } from "@hooks/useTypingEffect";
import { useNavigate } from "react-router-dom";
import { useState } from "react";

const sections = [
  { id: "projects", label: "Projets", route: "/projects" },
  { id: "skills", label: "Comp√©tences", route: "/skills" },
  { id: "experience", label: "Exp√©riences", route: "/experience" },
  { id: "education", label: "Formations", route: "/education" },
  { id: "skills map", label: "Skills map", route: "/visualization" },
  { id: "chatbot", label: "Chatbot", route: "/chatbot" },
];

const Home: React.FC = () => {
  const typedText = useTypingEffect("Salut, moi c‚Äôest Cl√©ment", 80);
  const navigate = useNavigate();
  const [isExiting, setIsExiting] = useState(false);

  const handleNavigate = async (to: string) => {
    if (isExiting) return;
    setIsExiting(true);

    if (to === "/visualization") {
      import("@pages/Visualization");
    } else if (to === "/") {
      import("@pages/Home");
    }
    await new Promise((resolve) => setTimeout(resolve, 2000));

    navigate(to);
  };

  return (
    <Layout>
      <PageWrapper zoom="in" animateExit={isExiting}>
        <section className="relative flex flex-col items-center justify-center w-full min-h-[calc(100vh-64px)] text-center overflow-hidden px-fluid-4">
          <div className="absolute inset-0 z-0">
            <ThreeBackground />
          </div>

          <motion.h1
            className="text-fluid-5xl sm:text-fluid-6xl md:text-fluid-4xl font-bold mb-fluid-3 text-accent flex items-center justify-center z-10"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ duration: 0.8 }}
          >
            <span>{typedText}</span>
            <span className="ml-1 w-1 h-10 bg-accent animate-pulse"></span>
          </motion.h1>

          <motion.p
            className="text-text-muted text-fluid-base sm:text-fluid-lg max-w-2xl mb-fluid-4 z-10"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.3, duration: 0.8 }}
          >
            √âtudiant en informatique √† la recherche d‚Äôun{" "}
            <span className="text-accent font-semibold">stage de fin d‚Äô√©tudes</span>.
            <br />
            Passionn√© par le d√©veloppement web, les syst√®mes intelligents et le design fonctionnel.
          </motion.p>

          <motion.div
            className="flex flex-wrap justify-center gap-fluid-4 mt-fluid-2 z-10"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6, duration: 0.8 }}
          >
            {sections.map((sec) => (
              <button
                key={sec.id}
                onClick={() => handleNavigate(sec.route)}
                className="px-fluid-6 py-fluid-2 rounded-full border border-[#333] text-text-main hover:border-accent hover:text-accent transition-all duration-300 bg-card shadow-md text-fluid-base md:text-fluid-lg"
              >
                {sec.label}
              </button>
            ))}
          </motion.div>
        </section>
      </PageWrapper>
    </Layout>
  );
};

export default Home;


===== frontend/src/pages/Contact.tsx =====




===== frontend/src/pages/Skills.tsx =====


import React, { useEffect, useState } from "react";
import type { SkillRead } from "../api/skill";
import { fetchSkills } from "../api/skill";
import Card from "../components/ui/Card";

const SkillsPage: React.FC = () => {
  const [skills, setSkills] = useState<SkillRead[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadSkills = async () => {
      try {
        const data = await fetchSkills();
        setSkills(data);
      } catch {
        setError("Erreur lors du chargement des comp√©tences.");
      } finally {
        setLoading(false);
      }
    };
    loadSkills();
  }, []);

  if (loading) return <p className="text-center mt-fluid-4 text-fluid-base">Chargement...</p>;
  if (error) return <p className="text-center mt-fluid-4 text-red-500 text-fluid-base">{error}</p>;

  return (
    <div className="container mx-auto px-fluid-4 py-fluid-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-fluid-4">
      {skills.map((skill) => (
        <Card
          key={skill.id}
          title={skill.name}
          tech_stack={skill.category ? `Cat√©gorie: ${skill.category}` : undefined}
          description={skill.level ? `Niveau: ${skill.level}` : undefined}
          image_url={undefined}
        />
      ))}
    </div>
  );
};

export default SkillsPage;


===== frontend/src/pages/Chatbot.tsx =====




===== frontend/src/pages/Education.tsx =====


import React, { useEffect, useState } from "react";
import type { EducationRead } from "../api/education";
import { fetchEducations } from "../api/education";
import Card from "../components/ui/Card";

const EducationPage: React.FC = () => {
  const [educations, setEducations] = useState<EducationRead[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadEducations = async () => {
      try {
        const data = await fetchEducations();
        setEducations(data);
      } catch {
        setError("Erreur lors du chargement des formations.");
      } finally {
        setLoading(false);
      }
    };
    loadEducations();
  }, []);

  if (loading) return <p className="text-center mt-fluid-4 text-fluid-base">Chargement...</p>;
  if (error) return <p className="text-center mt-fluid-4 text-red-500 text-fluid-base">{error}</p>;

  return (
    <div className="container mx-auto px-fluid-4 py-fluid-6 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-fluid-4">
      {educations.map((edu) => (
        <Card
          key={edu.id}
          title={edu.degree}
          description={edu.description}
          image_url={undefined}
          tech_stack={`${edu.school ?? ""} ‚Ä¢ ${edu.start_date ? new Date(edu.start_date).getFullYear() : ""} - ${edu.end_date ? new Date(edu.end_date).getFullYear() : "Pr√©sent"}`}
        />
      ))}
    </div>
  );
};

export default EducationPage;


===== frontend/src/pages/Admin.tsx =====




===== frontend/src/pages/Visualization.tsx =====


import Layout from "@components/layout/Layout";
import PageWrapper from "@components/layout/PageWrapper";
import ThreeScene from "@components/threeDemo/ThreeGraphScene";

const Visualization: React.FC = () => {
  return (
    <Layout>
      <PageWrapper zoom="out">
        <div className="w-screen h-screen">
          <ThreeScene />
        </div>
      </PageWrapper>
    </Layout>
  );
};

export default Visualization;


===== frontend/src/router/index.tsx =====


import { BrowserRouter as Router, Routes, Route, useLocation } from "react-router-dom";
import { AnimatePresence } from "framer-motion";
import Home from "@pages/Home";
import Visualization from "@pages/Visualization";

const AnimatedRoutes: React.FC = () => {
  const location = useLocation();

  return (
    <AnimatePresence mode="wait">
      <Routes location={location} key={location.pathname}>
        <Route path="/" element={<Home />} />
        <Route path="/visualization" element={<Visualization />} />
      </Routes>
    </AnimatePresence>
  );
};

const AppRouter: React.FC = () => (
  <Router>
    <AnimatedRoutes />
  </Router>
);

export default AppRouter;


===== frontend/src/router/PrivateRoute.tsx =====


import { Navigate } from "react-router-dom";
import { useAuth } from "@context/AuthContext";
import type { ReactElement } from "react";

interface PrivateRouteProps {
  children: ReactElement;
  adminOnly?: boolean;
}

export default function PrivateRoute({ children, adminOnly = false }: PrivateRouteProps) {
  const { user } = useAuth();

  if (!user) return <Navigate to="/login" replace />;
  if (adminOnly && !user.is_admin) return <Navigate to="/" replace />;

  return children;
}
